import { basename } from "path";
import {
  CopyObjectCommand,
  DeleteObjectCommand,
  GetObjectCommand,
} from "@aws-sdk/client-s3";
import { getLogger } from "@fox-finance/config";
import { ScanStatus, degradeIfDatabaseUnavailable, prisma } from "@fox-finance/prisma";
import { s3Client } from "../lib/s3";

const logger = getLogger();

const SCAN_DELAY_MS = Number(process.env.MALWARE_SCAN_DELAY_MS || 1000);
const SENSITIVITY = (process.env.MALWARE_SCAN_SENSITIVITY || "medium").toLowerCase();
const QUARANTINE_PREFIX = process.env.MALWARE_QUARANTINE_PREFIX || "quarantine";

const threatPatternsBySensitivity: Record<string, RegExp[]> = {
  low: [/eicar/i],
  medium: [/eicar/i, /virus/i, /malware/i, /trojan/i],
  high: [/eicar/i, /virus/i, /malware/i, /trojan/i, /suspicious/i, /infected/i],
};

const wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const detectThreat = (fileName: string): string | null => {
  const patterns = threatPatternsBySensitivity[SENSITIVITY] || threatPatternsBySensitivity.medium;
  const hit = patterns.find((pattern) => pattern.test(fileName));
  return hit ? `Matched malware signature rule: ${hit}` : null;
};

const quarantineUpload = async (
  sourceBucket: string,
  sourceKey: string,
  uploadId: string,
) => {
  const targetBucket = process.env.S3_QUARANTINE_BUCKET || sourceBucket;
  const fileName = basename(sourceKey);
  const targetKey = `${QUARANTINE_PREFIX}/${uploadId}-${fileName}`;

  await s3Client.send(
    new CopyObjectCommand({
      Bucket: targetBucket,
      CopySource: `${sourceBucket}/${sourceKey}`,
      Key: targetKey,
    }),
  );

  // Only delete from source after copy succeeds.
  await s3Client.send(
    new DeleteObjectCommand({
      Bucket: sourceBucket,
      Key: sourceKey,
    }),
  );

  return { targetBucket, targetKey };
};

const scanUpload = async (uploadId: string) => {
  const upload = await degradeIfDatabaseUnavailable(() =>
    prisma.upload.findUnique({
      where: { id: uploadId },
      select: { id: true, fileName: true, s3Bucket: true, s3Key: true },
    }),
  );

  if (!upload) {
    return;
  }

  await degradeIfDatabaseUnavailable(() =>
    prisma.upload.update({
      where: { id: uploadId },
      data: { scanStatus: ScanStatus.SCANNING, scanResult: null },
    }),
  );

  try {
    // Validate the object is still accessible before applying detection logic.
    await s3Client.send(
      new GetObjectCommand({
        Bucket: upload.s3Bucket,
        Key: upload.s3Key,
      }),
    );

    await wait(SCAN_DELAY_MS);

    const threat = detectThreat(upload.fileName);
    if (threat) {
      const { targetBucket, targetKey } = await quarantineUpload(
        upload.s3Bucket,
        upload.s3Key,
        upload.id,
      );

      await degradeIfDatabaseUnavailable(() =>
        prisma.upload.update({
          where: { id: upload.id },
          data: {
            scanStatus: ScanStatus.THREAT_DETECTED,
            scanResult: threat,
            scannedAt: new Date(),
            s3Bucket: targetBucket,
            s3Key: targetKey,
          },
        }),
      );

      logger.warn("Threat detected and file quarantined", {
        uploadId: upload.id,
        fileName: upload.fileName,
        threat,
      });
      return;
    }

    await degradeIfDatabaseUnavailable(() =>
      prisma.upload.update({
        where: { id: upload.id },
        data: {
          scanStatus: ScanStatus.CLEAN,
          scanResult: "No threats detected",
          scannedAt: new Date(),
        },
      }),
    );
  } catch (error) {
    logger.error("Malware scan failed", {
      uploadId,
      error: error instanceof Error ? error.message : String(error),
    });

    await degradeIfDatabaseUnavailable(() =>
      prisma.upload.update({
        where: { id: uploadId },
        data: {
          scanStatus: ScanStatus.FAILED,
          scanResult:
            error instanceof Error ? error.message : "Malware scan failed unexpectedly",
          scannedAt: new Date(),
        },
      }),
    );
  }
};

export const queueUploadScan = (uploadId: string) => {
  setImmediate(() => {
    void scanUpload(uploadId);
  });
};

