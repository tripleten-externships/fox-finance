// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum Role {
  ADMIN
  USER
}

enum Status {
  ACTIVE
  INACTIVE
}

enum UploadStatus {
  COMPLETE
  INCOMPLETE
}

enum DocumentType {
  GOVERNMENT_ID
  PASSPORT
  PROOF_OF_ADDRESS
  BANK_STATEMENT
  PAY_STUB
  TAX_RETURN
  OTHER //Can be specified in more detail by the client in the description field
}

// ============================================================================
// MODELS
// ============================================================================

model User {
  id          String       @id // Firebase UID â€” this is your canonical user identifier
  email       String       @unique
  name        String?
  photoUrl    String?
  role        Role         @default(USER)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  uploadLinks UploadLink[]
}

// ============================================================================
// TODO: Add your models here
// Students should define: Client, UploadLink, DocumentRequest, Upload models
// ============================================================================

model Client {
  //I assumed that a deletion of a client from the database should also result in a deletion of any associated 
  // upload links and document requests pertaining to that client. I did not assume the uploaded file would be deleted if the client is deleted.

  id          String       @id @default(uuid()) @db.Uuid
  email       String       @unique
  firstName   String
  lastName    String
  company     String
  phone       String
  status      Status       @default(ACTIVE)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  uploadLinks UploadLink[]

  @@index([phone])
  @@index([company])
  @@index([firstName])
  @@index([lastName])
}

model UploadLink {
  id               String            @id @default(uuid()) @db.Uuid
  client           Client            @relation(fields: [clientId], references: [id], onDelete: Cascade)
  clientId         String            @db.Uuid
  token            String            @unique
  expiresAt        DateTime
  isActive         Boolean           @default(false)
  createdBy        User              @relation(fields: [createdById], references: [id])
  createdById      String 
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  documentRequests DocumentRequest[]
  uploads          Upload[]
  UploadBatch      UploadBatch[]

  @@index([clientId])
  @@index([isActive, expiresAt])
}

model DocumentRequest {
  id                 String              @id @default(uuid()) @db.Uuid
  uploadLink         UploadLink          @relation(fields: [uploadLinkId], references: [id], onDelete: Cascade)
  uploadLinkId       String              @db.Uuid
  requestedDocuments RequestedDocument[] //Array of documents
  instructions       String
  status             UploadStatus        @default(INCOMPLETE) // Assumption: Upload status differs from the other status. An upload is either incomplete or complete.
  uploads            Upload[]
}

model RequestedDocument {
  id                String           @id @default(uuid()) @db.Uuid
  name              DocumentType //hard-coded list of document types as listed in the enum
  description       String
  documentRequest   DocumentRequest? @relation(fields: [documentRequestId], references: [id])
  documentRequestId String?  @db.Uuid
}

model Upload {
  id                String          @id @default(uuid()) @db.Uuid
  uploadLink        UploadLink      @relation(fields: [uploadLinkId], references: [id])
  uploadLinkId      String          @db.Uuid
  documentRequest   DocumentRequest? @relation(fields: [documentRequestId], references: [id])
  documentRequestId String?          @db.Uuid
  fileName          String
  fileSize          Decimal
  s3Key             String
  s3Bucket          String
  uploadedAt        DateTime        @updatedAt
  metadata          Json
  UploadBatch       UploadBatch?    @relation(fields: [uploadBatchId], references: [id])
  uploadBatchId     String?         @db.Uuid

  @@index([uploadLinkId])
  @@index([fileName])
}

model UploadBatch {
  id           String     @id @default(uuid()) @db.Uuid
  uploadLink   UploadLink @relation(fields: [uploadLinkId], references: [id])
  uploadLinkId String     @db.Uuid

  status        String
  totalFiles    Int
  uploadedFiles Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  uploads Upload[]
}
